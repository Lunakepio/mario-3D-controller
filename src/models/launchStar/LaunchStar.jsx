/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 .\launch-star.glb 
*/

import React, { useEffect, useRef } from 'react'
import { useGLTF } from '@react-three/drei'
import { useFrame } from '@react-three/fiber'
import gsap from 'gsap'
import { BallCollider, RigidBody } from '@react-three/rapier'
import { useGameStore } from '../../store/store'

export function LaunchStar(props) {
  const { nodes, materials } = useGLTF('./models/items/launch-star.glb')
  const groupRef = useRef()
  const upperStarRef = useRef()
  const lowerStarRef = useRef()
  
  const time = useRef(0)
  const animationSpeed = 0.5
  const amplitude = 0.3

  const timeline = useRef()
  const idle = useRef(true);
  const tweenProgress = useRef(0)

  const setStarPosition = useGameStore((state) => state.setStarPosition);
  const delay = useRef(2)
  useEffect(() => {
      
  if (!timeline.current && upperStarRef.current && lowerStarRef.current) {
    timeline.current = gsap.timeline({ paused: true})

    timeline.current
      .set(upperStarRef.current.rotation, { z: 0, y: 0, }, 0)
      .set(lowerStarRef.current.rotation, { z: 0, y: 0, }, 0)
      .to(upperStarRef.current.rotation, { y: Math.PI * 6, duration: 1, ease: "expo.out" }, 0)
      .to(lowerStarRef.current.rotation, { y: -Math.PI * 6, duration: 1, ease: "expo.out" }, 0)
      .to(lowerStarRef.current.position, { z: 15, duration: 1, ease: "ease.out" }, 0)
      .to(lowerStarRef.current.position, { z: 0, duration: 1, delay:0.1, ease: "elastic.out(2.5,0.2)"}, 1)
  }

  }, [])
  useFrame((state, delta) => {
    time.current += delta;
    const {starPosition, isTwirling } = useGameStore.getState()
    if(starPosition){
      delay.current -= isTwirling ? 0 : delta;
    }
    if(starPosition && isTwirling){
      idle.current = false;
    }
    if(groupRef.current, upperStarRef.current, lowerStarRef.current){
      if(idle.current){
        upperStarRef.current.rotation.z = Math.sin(time.current * animationSpeed) * amplitude;
        upperStarRef.current.rotation.y = Math.sin(time.current * animationSpeed) * amplitude;
        lowerStarRef.current.rotation.z = Math.cos(time.current * animationSpeed) * amplitude;
        lowerStarRef.current.rotation.y = Math.cos(time.current * animationSpeed) * amplitude;
      } else {
        if (timeline.current) {
          
          timeline.current.time(tweenProgress.current)
          if(timeline.current.progress() < 1){
            
          tweenProgress.current += delta
          }
        }
      }
    }
    
    if(delay.current <= 0){
      setStarPosition(null);
    }

  })
  return (
    <group  {...props}>
      <RigidBody sensor type="fixed" name="star" userData={{ star: true }} onIntersectionEnter={() =>{
        setStarPosition(lowerStarRef.current);
      }} onIntersectionExit={() => {
        delay.current = 2;
        tweenProgress.current = 0;
        idle.current = true;
      }}>
          <BallCollider args={[1.5]} />
      </RigidBody>
    <group dispose={null} rotation={[Math.PI / 3, Math.PI / 7, 0]} scale={0.1}>
      <group ref={groupRef} >
        <mesh ref={upperStarRef} geometry={nodes.gamemodel_objShape.geometry} material={materials['Material.002']} rotation={[-Math.PI / 2, 0, 0]} />
        <mesh ref={lowerStarRef} geometry={nodes.gamemodel_objShape001.geometry} material={materials['Material.001']} rotation={[-Math.PI / 2, 0, 0]} />
      </group>
    </group>
    </group>
  )
}

useGLTF.preload('./models/items/launch-star.glb')
